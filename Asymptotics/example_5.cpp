#include <iostream> 
#include <vector>

using namespace std;

int binary_search(vector<int> nums, int target) 
{
	int left = 0;
	int right = nums.size() - 1;
	while (left <= right) {
		int mid = (left + right) / 2;
		if (nums[mid] > target) {
			right = mid - 1;
		}
		else if (nums[mid] < target) {
			left = mid + 1;
		}
		else {
			return mid;
		}
	}

	return -1;
}

/*
Искать 9 в {1, 5, 8, 9, 11, 13, 15, 19, 21 }
	сравнить 9 с 11
	искать {1, 5, 8, 9 }
		сравнить 9 с 8
		искать в {9}
			сравнить 9 с 9
			равно!!!

Таким образом общее время выполнения оперделяется количеством
шагов  (последовательных делений на 2) => (n -> 1).
	n = 16
	1. n = 8
	2. n = 4
	3. n = 2
	4. n = 1

	=> 2 ^ 4 = 16
	=> O(log(n))
*/

int f(int num)
{
	if (num <= 0)
		return 1;

	return f(num - 1) + f(num - 1);
}

/*
											f(4)
						f(3)									f(3)
				f(2)				f(2)				f(2)			f(2)
			f(1)	f(1)		f(1)	f(1)		f(1)	f(1)	f(1)	f(1)

На каждом уровне кол-во узлов в 2-е больше чем на предыдущем, 
поэтому время выполнения составит O(2^n)

Если использовать рекурсивную функцию, которая пораждает вызовы то 
появляется такая закономерность: f(num - 1) + f(num - 1) => O(3^n)

Пространственная сложность (сложность по памяти) алгоритма составит O(n).
Так как когда мы нашли f(1) нам дальше искать не надо.
*/
